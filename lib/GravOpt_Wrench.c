/* This file was automatically generated by CasADi 3.6.5.
 *  It consists of: 
 *   1) content generated by CasADi runtime: not copyrighted
 *   2) template code copied from CasADi source: permissively licensed (MIT-0)
 *   3) user code: owned by the user
 *
 */
#ifdef __cplusplus
extern "C" {
#endif

/* How to prefix internal symbols */
#ifdef CASADI_CODEGEN_PREFIX
  #define CASADI_NAMESPACE_CONCAT(NS, ID) _CASADI_NAMESPACE_CONCAT(NS, ID)
  #define _CASADI_NAMESPACE_CONCAT(NS, ID) NS ## ID
  #define CASADI_PREFIX(ID) CASADI_NAMESPACE_CONCAT(CODEGEN_PREFIX, ID)
#else
  #define CASADI_PREFIX(ID) GravOpt_Wrench_ ## ID
#endif

#include <math.h>
#include <coin-or/IpStdCInterface.h>

#ifndef casadi_real
#define casadi_real double
#endif

#ifndef casadi_int
#define casadi_int long long int
#endif

#ifndef CASADI_MAX_NUM_THREADS
#define CASADI_MAX_NUM_THREADS 1
#endif

#ifndef casadi_inf
#define casadi_inf INFINITY
#endif

/* Add prefix to internal symbols */
#define casadi_clear CASADI_PREFIX(clear)
#define casadi_copy CASADI_PREFIX(copy)
#define casadi_densify CASADI_PREFIX(densify)
#define casadi_f0 CASADI_PREFIX(f0)
#define casadi_f1 CASADI_PREFIX(f1)
#define casadi_f1_alloc_mem CASADI_PREFIX(f1_alloc_mem)
#define casadi_f1_init_mem CASADI_PREFIX(f1_init_mem)
#define casadi_f1_mem CASADI_PREFIX(f1_mem)
#define casadi_f1_mem_counter CASADI_PREFIX(f1_mem_counter)
#define casadi_f1_unused_stack CASADI_PREFIX(f1_unused_stack)
#define casadi_f1_unused_stack_counter CASADI_PREFIX(f1_unused_stack_counter)
#define casadi_f2 CASADI_PREFIX(f2)
#define casadi_f3 CASADI_PREFIX(f3)
#define casadi_f4 CASADI_PREFIX(f4)
#define casadi_f5 CASADI_PREFIX(f5)
#define casadi_f6 CASADI_PREFIX(f6)
#define casadi_f7 CASADI_PREFIX(f7)
#define casadi_fabs CASADI_PREFIX(fabs)
#define casadi_fill CASADI_PREFIX(fill)
#define casadi_fmax CASADI_PREFIX(fmax)
#define casadi_ipopt_data CASADI_PREFIX(ipopt_data)
#define casadi_ipopt_free_mem CASADI_PREFIX(ipopt_free_mem)
#define casadi_ipopt_hess_l_empty CASADI_PREFIX(ipopt_hess_l_empty)
#define casadi_ipopt_init CASADI_PREFIX(ipopt_init)
#define casadi_ipopt_init_mem CASADI_PREFIX(ipopt_init_mem)
#define casadi_ipopt_presolve CASADI_PREFIX(ipopt_presolve)
#define casadi_ipopt_setup CASADI_PREFIX(ipopt_setup)
#define casadi_ipopt_solve CASADI_PREFIX(ipopt_solve)
#define casadi_ipopt_sparsity CASADI_PREFIX(ipopt_sparsity)
#define casadi_ipopt_work CASADI_PREFIX(ipopt_work)
#define casadi_mtimes CASADI_PREFIX(mtimes)
#define casadi_nlp_f0 CASADI_PREFIX(nlp_f0)
#define casadi_nlp_g0 CASADI_PREFIX(nlp_g0)
#define casadi_nlp_grad_f0 CASADI_PREFIX(nlp_grad_f0)
#define casadi_nlp_hess_l0 CASADI_PREFIX(nlp_hess_l0)
#define casadi_nlp_jac_g0 CASADI_PREFIX(nlp_jac_g0)
#define casadi_nlpsol_data CASADI_PREFIX(nlpsol_data)
#define casadi_nlpsol_detect_bounds_after CASADI_PREFIX(nlpsol_detect_bounds_after)
#define casadi_nlpsol_detect_bounds_before CASADI_PREFIX(nlpsol_detect_bounds_before)
#define casadi_nlpsol_detect_bounds_data CASADI_PREFIX(nlpsol_detect_bounds_data)
#define casadi_nlpsol_detect_bounds_prob CASADI_PREFIX(nlpsol_detect_bounds_prob)
#define casadi_nlpsol_init CASADI_PREFIX(nlpsol_init)
#define casadi_nlpsol_prob CASADI_PREFIX(nlpsol_prob)
#define casadi_nlpsol_work CASADI_PREFIX(nlpsol_work)
#define casadi_project CASADI_PREFIX(project)
#define casadi_s0 CASADI_PREFIX(s0)
#define casadi_s1 CASADI_PREFIX(s1)
#define casadi_s10 CASADI_PREFIX(s10)
#define casadi_s11 CASADI_PREFIX(s11)
#define casadi_s12 CASADI_PREFIX(s12)
#define casadi_s13 CASADI_PREFIX(s13)
#define casadi_s14 CASADI_PREFIX(s14)
#define casadi_s15 CASADI_PREFIX(s15)
#define casadi_s16 CASADI_PREFIX(s16)
#define casadi_s17 CASADI_PREFIX(s17)
#define casadi_s18 CASADI_PREFIX(s18)
#define casadi_s19 CASADI_PREFIX(s19)
#define casadi_s2 CASADI_PREFIX(s2)
#define casadi_s20 CASADI_PREFIX(s20)
#define casadi_s21 CASADI_PREFIX(s21)
#define casadi_s22 CASADI_PREFIX(s22)
#define casadi_s23 CASADI_PREFIX(s23)
#define casadi_s24 CASADI_PREFIX(s24)
#define casadi_s25 CASADI_PREFIX(s25)
#define casadi_s26 CASADI_PREFIX(s26)
#define casadi_s27 CASADI_PREFIX(s27)
#define casadi_s28 CASADI_PREFIX(s28)
#define casadi_s29 CASADI_PREFIX(s29)
#define casadi_s3 CASADI_PREFIX(s3)
#define casadi_s30 CASADI_PREFIX(s30)
#define casadi_s31 CASADI_PREFIX(s31)
#define casadi_s32 CASADI_PREFIX(s32)
#define casadi_s33 CASADI_PREFIX(s33)
#define casadi_s34 CASADI_PREFIX(s34)
#define casadi_s35 CASADI_PREFIX(s35)
#define casadi_s4 CASADI_PREFIX(s4)
#define casadi_s5 CASADI_PREFIX(s5)
#define casadi_s6 CASADI_PREFIX(s6)
#define casadi_s7 CASADI_PREFIX(s7)
#define casadi_s8 CASADI_PREFIX(s8)
#define casadi_s9 CASADI_PREFIX(s9)
#define casadi_scal CASADI_PREFIX(scal)
#define casadi_trans CASADI_PREFIX(trans)

/* Symbol visibility in DLLs */
#ifndef CASADI_SYMBOL_EXPORT
  #if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
    #if defined(STATIC_LINKED)
      #define CASADI_SYMBOL_EXPORT
    #else
      #define CASADI_SYMBOL_EXPORT __declspec(dllexport)
    #endif
  #elif defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
    #define CASADI_SYMBOL_EXPORT __attribute__ ((visibility ("default")))
  #else
    #define CASADI_SYMBOL_EXPORT
  #endif
#endif

void casadi_fill(casadi_real* x, casadi_int n, casadi_real alpha) {
  casadi_int i;
  if (x) {
    for (i=0; i<n; ++i) *x++ = alpha;
  }
}

casadi_real casadi_fabs(casadi_real x) {
/* Pre-c99 compatibility */
#if __STDC_VERSION__ < 199901L
  return x>0 ? x : -x;
#else
  return fabs(x);
#endif
}

void casadi_clear(casadi_real* x, casadi_int n) {
  casadi_int i;
  if (x) {
    for (i=0; i<n; ++i) *x++ = 0;
  }
}

void casadi_copy(const casadi_real* x, casadi_int n, casadi_real* y) {
  casadi_int i;
  if (y) {
    if (x) {
      for (i=0; i<n; ++i) *y++ = *x++;
    } else {
      for (i=0; i<n; ++i) *y++ = 0.;
    }
  }
}

void casadi_trans(const casadi_real* x, const casadi_int* sp_x, casadi_real* y,
    const casadi_int* sp_y, casadi_int* tmp) {
  casadi_int ncol_x, nnz_x, ncol_y, k;
  const casadi_int* row_x, *colind_y;
  ncol_x = sp_x[1];
  nnz_x = sp_x[2 + ncol_x];
  row_x = sp_x + 2 + ncol_x+1;
  ncol_y = sp_y[1];
  colind_y = sp_y+2;
  for (k=0; k<ncol_y; ++k) tmp[k] = colind_y[k];
  for (k=0; k<nnz_x; ++k) {
    y[tmp[row_x[k]]++] = x[k];
  }
}

void casadi_mtimes(const casadi_real* x, const casadi_int* sp_x, const casadi_real* y, const casadi_int* sp_y, casadi_real* z, const casadi_int* sp_z, casadi_real* w, casadi_int tr) {
  casadi_int ncol_x, ncol_y, ncol_z, cc;
  const casadi_int *colind_x, *row_x, *colind_y, *row_y, *colind_z, *row_z;
  ncol_x = sp_x[1];
  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;
  ncol_y = sp_y[1];
  colind_y = sp_y+2; row_y = sp_y + 2 + ncol_y+1;
  ncol_z = sp_z[1];
  colind_z = sp_z+2; row_z = sp_z + 2 + ncol_z+1;
  if (tr) {
    for (cc=0; cc<ncol_z; ++cc) {
      casadi_int kk;
      for (kk=colind_y[cc]; kk<colind_y[cc+1]; ++kk) {
        w[row_y[kk]] = y[kk];
      }
      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {
        casadi_int kk1;
        casadi_int rr = row_z[kk];
        for (kk1=colind_x[rr]; kk1<colind_x[rr+1]; ++kk1) {
          z[kk] += x[kk1] * w[row_x[kk1]];
        }
      }
    }
  } else {
    for (cc=0; cc<ncol_y; ++cc) {
      casadi_int kk;
      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {
        w[row_z[kk]] = z[kk];
      }
      for (kk=colind_y[cc]; kk<colind_y[cc+1]; ++kk) {
        casadi_int kk1;
        casadi_int rr = row_y[kk];
        for (kk1=colind_x[rr]; kk1<colind_x[rr+1]; ++kk1) {
          w[row_x[kk1]] += x[kk1]*y[kk];
        }
      }
      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {
        z[kk] = w[row_z[kk]];
      }
    }
  }
}

#define CASADI_CAST(x,y) ((x) y)

void casadi_densify(const casadi_real* x, const casadi_int* sp_x, casadi_real* y, casadi_int tr) {
  casadi_int nrow_x, ncol_x, i, el;
  const casadi_int *colind_x, *row_x;
  if (!y) return;
  nrow_x = sp_x[0]; ncol_x = sp_x[1];
  colind_x = sp_x+2; row_x = sp_x+ncol_x+3;
  casadi_clear(y, nrow_x*ncol_x);
  if (!x) return;
  if (tr) {
    for (i=0; i<ncol_x; ++i) {
      for (el=colind_x[i]; el!=colind_x[i+1]; ++el) {
        y[i + row_x[el]*ncol_x] = CASADI_CAST(casadi_real, *x++);
      }
    }
  } else {
    for (i=0; i<ncol_x; ++i) {
      for (el=colind_x[i]; el!=colind_x[i+1]; ++el) {
        y[row_x[el]] = CASADI_CAST(casadi_real, *x++);
      }
      y += nrow_x;
    }
  }
}

struct casadi_nlpsol_detect_bounds_prob {
  casadi_int sz_arg;
  casadi_int sz_res;
  casadi_int sz_iw;
  casadi_int sz_w;
  casadi_int ng;
  casadi_int nb;
  const casadi_int *target_x;
  const casadi_int *target_g;
  const char *is_simple;
  int (*callback)(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, void* callback_data);
  void* callback_data;
};
struct casadi_nlpsol_prob {
  casadi_int nx, ng, np;
  struct casadi_nlpsol_detect_bounds_prob detect_bounds;
};
struct casadi_nlpsol_detect_bounds_data {
  const casadi_real** arg;
  casadi_real** res;
  casadi_int* iw;
  casadi_real* w;
  casadi_real* a;
  casadi_real* b;
  casadi_int* target_l;
  casadi_int* target_u;
  casadi_real* lam_xl;
  casadi_real* lam_xu;
};
struct casadi_nlpsol_data {
  const struct casadi_nlpsol_prob* prob;
  casadi_real *lbz, *ubz;
  casadi_real *z;
  casadi_real *lam;
  casadi_real objective;
  const casadi_real *p, *lbx, *ubx, *lbg, *ubg, *x0, *lam_x0, *lam_g0;
  casadi_real *f, *x, *g, *lam_x, *lam_g, *lam_p;
  struct casadi_nlpsol_detect_bounds_data detect_bounds;
};
void casadi_nlpsol_work(const struct casadi_nlpsol_prob* p, casadi_int* sz_arg, casadi_int* sz_res,
    casadi_int* sz_iw, casadi_int* sz_w) {
  *sz_arg = *sz_res = 0;
  *sz_w = *sz_iw = 0;
  *sz_w += p->nx + p->ng;
  *sz_w += p->nx + p->ng;
  *sz_w += p->nx + p->ng;
  *sz_w += p->nx + p->ng;
  if (p->detect_bounds.ng) {
    *sz_arg += p->detect_bounds.sz_arg;
    *sz_res += p->detect_bounds.sz_res;
    *sz_iw += p->detect_bounds.sz_iw;
    *sz_w += p->detect_bounds.sz_w;
    *sz_w += p->detect_bounds.nb;
    *sz_w += p->detect_bounds.nb;
    *sz_iw += p->nx;
    *sz_iw += p->nx;
    *sz_w += p->nx;
    *sz_w += p->nx;
  }
}
void casadi_nlpsol_init(struct casadi_nlpsol_data* d, const casadi_real*** arg, casadi_real*** res,
    casadi_int** iw, casadi_real** w) {
  casadi_int nx, ng;
  const struct casadi_nlpsol_prob* p = d->prob;
  nx = p->nx;
  ng = p->ng;
  d->z = *w; *w += nx + ng;
  d->lbz = *w; *w += nx + ng;
  d->ubz = *w; *w += nx + ng;
  d->lam = *w; *w += nx + ng;
  if (p->detect_bounds.ng) {
    d->detect_bounds.arg = *arg; *arg += p->detect_bounds.sz_arg;
    d->detect_bounds.res = *res; *res += p->detect_bounds.sz_res;
    d->detect_bounds.iw = *iw; *iw += p->detect_bounds.sz_iw;
    d->detect_bounds.w = *w; *w += p->detect_bounds.sz_w;
    d->detect_bounds.a = *w; *w += p->detect_bounds.nb;
    d->detect_bounds.b = *w; *w += p->detect_bounds.nb;
    d->detect_bounds.target_l = *iw; *iw += p->nx;
    d->detect_bounds.target_u = *iw; *iw += p->nx;
    d->detect_bounds.lam_xl = *w; *w += nx;
    d->detect_bounds.lam_xu = *w; *w += nx;
  }
}
int casadi_detect_bounds_before(struct casadi_nlpsol_data* d_nlp) {
  const struct casadi_nlpsol_prob* p_nlp = d_nlp->prob;
  struct casadi_nlpsol_detect_bounds_data* d_bounds = &d_nlp->detect_bounds;
  const struct casadi_nlpsol_detect_bounds_prob* p_bounds = &p_nlp->detect_bounds;
  casadi_int nx = p_nlp->nx;
  d_bounds->arg[0] = d_nlp->p;
  d_bounds->res[0] = d_bounds->a;
  d_bounds->res[1] = d_bounds->b;
  p_bounds->callback(d_bounds->arg, d_bounds->res,
    d_bounds->iw, d_bounds->w, p_bounds->callback_data);
  for (casadi_int i=0;i<p_bounds->nb;++i) {
    if (d_bounds->a[i]==0) {
      casadi_int k = p_bounds->target_g[i];
      if (d_nlp->lbg[k]>d_bounds->b[i]) return 1;
      if (d_nlp->ubg[k]<d_bounds->b[i]) return 1;
    }
  }
  casadi_real* lbz = d_nlp->lbz+nx;
  casadi_real* ubz = d_nlp->ubz+nx;
  casadi_real* lam = d_nlp->lam+nx;
  for (casadi_int i=0;i<nx;++i) {
    d_bounds->lam_xl[i] = d_nlp->lam_x0 ? (d_nlp->lam_x0[i]<0)*d_nlp->lam_x0[i] : 0.;
    d_bounds->lam_xu[i] = d_nlp->lam_x0 ? (d_nlp->lam_x0[i]>0)*d_nlp->lam_x0[i] : 0.;
  }
  for (casadi_int i=0;i<nx;++i) {
    d_bounds->target_l[i] = i;
    d_bounds->target_u[i] = i;
  }
  casadi_int k=0;
  for (casadi_int i=0;i<p_bounds->ng;++i) {
    if (p_bounds->is_simple[i]) {
      casadi_real lb = (d_nlp->lbg[i]-d_bounds->b[k])/casadi_fabs(d_bounds->a[k]);
      casadi_real ub = (d_nlp->ubg[i]-d_bounds->b[k])/casadi_fabs(d_bounds->a[k]);
      casadi_int j = p_bounds->target_x[k];
      if (lb==d_nlp->lbz[j]) {
        if (d_nlp->lam_g0) d_bounds->lam_xl[j] += (d_nlp->lam_g0[i]<0)*d_nlp->lam_g0[i];
      } else if (lb>d_nlp->lbz[j]) {
        d_nlp->lbz[j] = lb;
        d_bounds->target_l[j] = nx+i;
        if (d_nlp->lam_g0) d_bounds->lam_xl[j] = (d_nlp->lam_g0[i]<0)*d_nlp->lam_g0[i];
      }
      if (ub==d_nlp->ubz[j]) {
        if (d_nlp->lam_g0) d_bounds->lam_xu[j] += (d_nlp->lam_g0[i]>0)*d_nlp->lam_g0[i];
      } else if (ub<d_nlp->ubz[j]) {
        d_nlp->ubz[j] = ub;
        d_bounds->target_u[j] = nx+i;
        if (d_nlp->lam_g0) d_bounds->lam_xu[j] = (d_nlp->lam_g0[i]>0)*d_nlp->lam_g0[i];
      }
      k++;
    } else {
      *lbz++ = d_nlp->lbg[i];
      *ubz++ = d_nlp->ubg[i];
      if (d_nlp->lam_g0) *lam++ = d_nlp->lam_g0[i];
    }
  }
  for (casadi_int i=0;i<nx;++i) {
    d_nlp->lam[i] = d_bounds->lam_xl[i]+d_bounds->lam_xu[i];
  }
  return 0;
}
int casadi_detect_bounds_after(struct casadi_nlpsol_data* d_nlp) {
  const struct casadi_nlpsol_prob* p_nlp = d_nlp->prob;
  struct casadi_nlpsol_detect_bounds_data* d_bounds = &d_nlp->detect_bounds;
  const struct casadi_nlpsol_detect_bounds_prob* p_bounds = &p_nlp->detect_bounds;
  casadi_int nx = p_nlp->nx;
  casadi_fill(d_nlp->lam_x, nx, 0.);
  casadi_fill(d_nlp->lam_g, p_bounds->ng, 0.);
  casadi_int k = 0;
  casadi_int k_normal = 0;
  for (casadi_int i=0;i<p_bounds->ng;++i) {
    if (p_bounds->is_simple[i]) {
      casadi_int j = p_bounds->target_x[k];
      if (d_nlp->g) d_nlp->g[i] = d_bounds->a[k]*d_nlp->z[j]+d_bounds->b[k];
      k++;
    } else {
      if (d_nlp->g) d_nlp->g[i] = d_nlp->z[nx+k_normal];
      if (d_nlp->lam_g) d_nlp->lam_g[i] = d_nlp->lam[nx+k_normal];
      k_normal++;
    }
  }
  for (casadi_int i=0;i<nx;++i) {
    if (d_bounds->target_l[i]<nx) {
      if (d_nlp->lam_x) d_nlp->lam_x[i] += (d_nlp->lam[i]<0)*d_nlp->lam[i];
    } else {
      if (d_nlp->lam_g)
        d_nlp->lam_g[d_bounds->target_l[i]-nx] += (d_nlp->lam[i]<0)*d_nlp->lam[i];
    }
    if (d_bounds->target_u[i]<nx) {
      if (d_nlp->lam_x) d_nlp->lam_x[i] += (d_nlp->lam[i]>0)*d_nlp->lam[i];
    } else {
      if (d_nlp->lam_g)
        d_nlp->lam_g[d_bounds->target_u[i]-nx] += (d_nlp->lam[i]>0)*d_nlp->lam[i];
    }
  }
  return 0;
}

casadi_real casadi_fmax(casadi_real x, casadi_real y) {
/* Pre-c99 compatibility */
#if __STDC_VERSION__ < 199901L
  return x>y ? x : y;
#else
  return fmax(x, y);
#endif
}

void casadi_project(const casadi_real* x, const casadi_int* sp_x, casadi_real* y, const casadi_int* sp_y, casadi_real* w) {
  casadi_int ncol_x, ncol_y, i, el;
  const casadi_int *colind_x, *row_x, *colind_y, *row_y;
  ncol_x = sp_x[1];
  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;
  ncol_y = sp_y[1];
  colind_y = sp_y+2; row_y = sp_y + 2 + ncol_y+1;
  for (i=0; i<ncol_x; ++i) {
    for (el=colind_y[i]; el<colind_y[i+1]; ++el) w[row_y[el]] = 0;
    for (el=colind_x[i]; el<colind_x[i+1]; ++el) w[row_x[el]] = x[el];
    for (el=colind_y[i]; el<colind_y[i+1]; ++el) y[el] = w[row_y[el]];
  }
}

struct casadi_ipopt_prob {
  const struct casadi_nlpsol_prob* nlp;
  const casadi_int *sp_h, *sp_a;
  casadi_int nnz_h, nnz_a;
  Eval_F_CB eval_f;
  Eval_G_CB eval_g;
  Eval_Grad_F_CB eval_grad_f;
  Eval_Jac_G_CB eval_jac_g;
  Eval_H_CB eval_h;
};
void casadi_ipopt_setup(struct casadi_ipopt_prob* p) {
  if (p->sp_h) {
    p->nnz_h = p->sp_h[2+p->sp_h[1]];
  } else {
    p->nnz_h = 0;
  }
  p->nnz_a = p->sp_a[2+p->sp_a[1]];
}
struct casadi_ipopt_data {
  const struct casadi_ipopt_prob* prob;
  struct casadi_nlpsol_data* nlp;
  IpoptProblem ipopt;
  const casadi_real** arg;
  casadi_real** res;
  casadi_int* iw;
  casadi_real* w;
  casadi_real *z_L, *z_U;
  enum ApplicationReturnStatus status;
  int unified_return_status;
  int success;
};
int ipopt_init_mem(struct casadi_ipopt_data* d) {
  return 0;
}
void ipopt_free_mem(struct casadi_ipopt_data* d) {
}
void casadi_ipopt_work(const struct casadi_ipopt_prob* p, casadi_int* sz_arg, casadi_int* sz_res, casadi_int* sz_iw, casadi_int* sz_w) {
  casadi_nlpsol_work(p->nlp, sz_arg, sz_res, sz_iw, sz_w);
  *sz_w += p->nlp->nx;
  *sz_w += p->nlp->nx;
}
void casadi_ipopt_init(struct casadi_ipopt_data* d, const casadi_real*** arg, casadi_real*** res, casadi_int** iw, casadi_real** w) {
  const struct casadi_ipopt_prob* p = d->prob;
  const struct casadi_nlpsol_prob* p_nlp = p->nlp;
  d->z_L = *w; *w += p_nlp->nx;
  d->z_U = *w; *w += p_nlp->nx;
  d->arg = *arg;
  d->res = *res;
  d->iw = *iw;
  d->w = *w;
}
void casadi_ipopt_presolve(struct casadi_ipopt_data* d) {
  const struct casadi_ipopt_prob* p = d->prob;
  const struct casadi_nlpsol_prob* p_nlp = p->nlp;
  const struct casadi_nlpsol_data* d_nlp = d->nlp;
  d->ipopt = CreateIpoptProblem(
                p_nlp->nx, (double *) d_nlp->lbz, (double *) d_nlp->ubz,
                p_nlp->ng, (double *) d_nlp->lbz+p_nlp->nx,
                           (double *) d_nlp->ubz+p_nlp->nx,
                p->nnz_a, p->nnz_h, 0,
                p->eval_f, p->eval_g, p->eval_grad_f,
                p->eval_jac_g, p->eval_h);
}
void casadi_ipopt_solve(struct casadi_ipopt_data* d) {
  const struct casadi_ipopt_prob* p = d->prob;
  const struct casadi_nlpsol_prob* p_nlp = p->nlp;
  struct casadi_nlpsol_data* d_nlp = d->nlp;
  d->unified_return_status = 1;
  for (casadi_int i=0; i<p_nlp->nx; ++i) {
    d->z_L[i] = casadi_fmax(0., -d_nlp->lam[i]);
    d->z_U[i] = casadi_fmax(0., d_nlp->lam[i]);
  }
  d->status = IpoptSolve(d->ipopt, d_nlp->z, d_nlp->z + p_nlp->nx, &d_nlp->objective, d_nlp->lam+p_nlp->nx, d->z_L, d->z_U, d);
  for (casadi_int i=0; i<p_nlp->nx; ++i) {
    d_nlp->lam[i] = d->z_U[i]-d->z_L[i];
  }
  FreeIpoptProblem(d->ipopt);
  if (d->status==Solve_Succeeded ||
      d->status==Solved_To_Acceptable_Level ||
      d->status==Feasible_Point_Found) {
        d->unified_return_status = 0;
  } else if (d->status==Maximum_Iterations_Exceeded) {
      d->unified_return_status = 2;
  }
  #if (IPOPT_VERSION_MAJOR > 3) || (IPOPT_VERSION_MAJOR == 3 && IPOPT_VERSION_MINOR >= 14)
    if (d->status==Maximum_WallTime_Exceeded) d->unified_return_status = 2;
  #endif
  d->success = (d->unified_return_status == 0);
}
void casadi_ipopt_sparsity(const casadi_int* sp, ipindex *iRow, ipindex *jCol) {
    casadi_int ncol = sp[1];
    const casadi_int* colind = sp+2;
    const casadi_int* row = colind+ncol+1;
    for (casadi_int cc=0; cc<ncol; ++cc) {
        for (casadi_int el=colind[cc]; el<colind[cc+1]; ++el) {
            *iRow++ = row[el];
            *jCol++ = cc;
        }
    }
}
bool casadi_ipopt_hess_l_empty(ipindex n, ipnumber *x, bool new_x, ipnumber obj_factor, ipindex m, ipnumber *lambda, bool new_lambda, ipindex nele_hess, ipindex *iRow, ipindex *jCol, ipnumber *values, UserDataPtr user_data) {
  return false;
}

void casadi_scal(casadi_int n, casadi_real alpha, casadi_real* x) {
  casadi_int i;
  if (!x) return;
  for (i=0; i<n; ++i) *x++ *= alpha;
}

static int casadi_f1_mem_counter = 0;
static int casadi_f1_unused_stack_counter = -1;
static int casadi_f1_unused_stack[CASADI_MAX_NUM_THREADS];
static struct casadi_ipopt_data casadi_f1_mem[CASADI_MAX_NUM_THREADS];

static const casadi_int casadi_s0[9] = {6, 3, 0, 1, 2, 3, 0, 1, 2};
static const casadi_int casadi_s1[12] = {3, 6, 0, 1, 2, 3, 3, 3, 3, 0, 1, 2};
static const casadi_int casadi_s2[27] = {7, 3, 0, 7, 14, 21, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6};
static const casadi_int casadi_s3[51] = {7, 6, 0, 7, 14, 21, 28, 35, 42, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6};
static const casadi_int casadi_s4[111] = {119, 1, 0, 107, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 109, 110, 111, 112, 113, 114, 115};
static const casadi_int casadi_s5[11] = {7, 1, 0, 7, 0, 1, 2, 3, 4, 5, 6};
static const casadi_int casadi_s6[5] = {3, 1, 0, 1, 0};
static const casadi_int casadi_s7[5] = {3, 1, 0, 1, 1};
static const casadi_int casadi_s8[5] = {3, 1, 0, 1, 2};
static const casadi_int casadi_s9[41] = {7, 10, 0, 1, 2, 3, 4, 5, 6, 7, 14, 21, 28, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6};
static const casadi_int casadi_s10[38] = {10, 7, 0, 4, 8, 12, 16, 20, 24, 28, 0, 7, 8, 9, 1, 7, 8, 9, 2, 7, 8, 9, 3, 7, 8, 9, 4, 7, 8, 9, 5, 7, 8, 9, 6, 7, 8, 9};
static const casadi_int casadi_s11[17] = {1, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 0, 0, 0, 0, 0, 0};
static const casadi_int casadi_s12[59] = {7, 7, 0, 7, 14, 21, 28, 35, 42, 49, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6};
static const casadi_int casadi_s13[11] = {1, 7, 0, 1, 1, 1, 1, 1, 1, 1, 0};
static const casadi_int casadi_s14[9] = {1, 3, 0, 1, 2, 3, 0, 0, 0};
static const casadi_int casadi_s15[15] = {3, 3, 0, 3, 6, 9, 0, 1, 2, 0, 1, 2, 0, 1, 2};
static const casadi_int casadi_s16[7] = {1, 3, 0, 1, 1, 1, 0};
static const casadi_int casadi_s17[10] = {0, 1, 2, 3, 4, 5, 6, 49, 50, 51};
static const casadi_int casadi_s18[10] = {0, 7, 14, 21, 28, 35, 42, 49, 52, 55};
static const casadi_int casadi_s19[11] = {1, 7, 0, 0, 1, 1, 1, 1, 1, 1, 0};
static const casadi_int casadi_s20[7] = {1, 3, 0, 0, 1, 1, 0};
static const casadi_int casadi_s21[10] = {7, 8, 9, 10, 11, 12, 13, 52, 53, 54};
static const casadi_int casadi_s22[10] = {1, 8, 15, 22, 29, 36, 43, 50, 53, 56};
static const casadi_int casadi_s23[11] = {1, 7, 0, 0, 0, 1, 1, 1, 1, 1, 0};
static const casadi_int casadi_s24[7] = {1, 3, 0, 0, 0, 1, 0};
static const casadi_int casadi_s25[10] = {14, 15, 16, 17, 18, 19, 20, 55, 56, 57};
static const casadi_int casadi_s26[10] = {2, 9, 16, 23, 30, 37, 44, 51, 54, 57};
static const casadi_int casadi_s27[11] = {1, 7, 0, 0, 0, 0, 1, 1, 1, 1, 0};
static const casadi_int casadi_s28[11] = {1, 7, 0, 0, 0, 0, 0, 1, 1, 1, 0};
static const casadi_int casadi_s29[11] = {1, 7, 0, 0, 0, 0, 0, 0, 1, 1, 0};
static const casadi_int casadi_s30[11] = {1, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0};
static const casadi_int casadi_s31[71] = {10, 10, 0, 7, 14, 21, 28, 35, 42, 49, 52, 55, 58, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 7, 8, 9, 7, 8, 9};
static const casadi_int casadi_s32[47] = {10, 10, 0, 1, 3, 6, 10, 15, 21, 28, 29, 31, 34, 0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 7, 7, 8, 7, 8, 9};
static const casadi_int casadi_s33[52] = {6, 7, 0, 6, 12, 18, 24, 30, 36, 42, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5};
static const casadi_int casadi_s34[5] = {1, 1, 0, 1, 0};
static const casadi_int casadi_s35[7] = {3, 1, 0, 3, 0, 1, 2};

/* nlp_grad:(x[10],p[119],lam_f,lam_g[7])->(f,g[7],grad_gamma_x[10],grad_gamma_p[119]) */
static int casadi_f2(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i, j, k;
  casadi_real *rr, *ss, *tt;
  const casadi_real *cr, *cs;
  casadi_real w0, *w1=w+8, *w2=w+15, *w3=w+22, *w4=w+29, w5, *w6=w+79, *w7=w+82, *w8=w+85, *w9=w+88, *w10=w+97, *w11=w+118, *w12=w+160, *w14=w+202, *w15=w+205, *w16=w+212, *w17=w+219, *w18=w+268, *w19=w+289, *w20=w+292, *w24=w+301, *w25=w+408;
  /* #0: @0 = 0 */
  w0 = 0.;
  /* #1: @1 = zeros(1x7) */
  casadi_clear(w1, 7);
  /* #2: @2 = input[0][0] */
  casadi_copy(arg[0], 7, w2);
  /* #3: @3 = @2' */
  casadi_copy(w2, 7, w3);
  /* #4: @4 = input[1][0] */
  casadi_copy(arg[1], 49, w4);
  /* #5: @1 = mac(@3,@4,@1) */
  for (i=0, rr=w1; i<7; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w3+j, tt=w4+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #6: @0 = mac(@1,@2,@0) */
  for (i=0, rr=(&w0); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w1+j, tt=w2+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #7: @5 = 0 */
  w5 = 0.;
  /* #8: @6 = zeros(1x3) */
  casadi_clear(w6, 3);
  /* #9: @7 = input[0][1] */
  casadi_copy(arg[0] ? arg[0]+7 : 0, 3, w7);
  /* #10: @8 = @7' */
  casadi_copy(w7, 3, w8);
  /* #11: @9 = input[1][1] */
  casadi_copy(arg[1] ? arg[1]+49 : 0, 9, w9);
  /* #12: @6 = mac(@8,@9,@6) */
  for (i=0, rr=w6; i<3; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w8+j, tt=w9+i*3; k<3; ++k) *rr += ss[k*1]**tt++;
  /* #13: @5 = mac(@6,@7,@5) */
  for (i=0, rr=(&w5); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w6+j, tt=w7+i*3; k<3; ++k) *rr += ss[k*1]**tt++;
  /* #14: @0 = (@0+@5) */
  w0 += w5;
  /* #15: output[0][0] = @0 */
  if (res[0]) res[0][0] = w0;
  /* #16: @3 = zeros(7x1) */
  casadi_clear(w3, 7);
  /* #17: @10 = zeros(7x3) */
  casadi_clear(w10, 21);
  /* #18: @11 = input[1][2] */
  casadi_copy(arg[1] ? arg[1]+58 : 0, 42, w11);
  /* #19: @12 = @11' */
  for (i=0, rr=w12, cs=w11; i<7; ++i) for (j=0; j<6; ++j) rr[i+j*7] = *cs++;
  /* #20: @8 = ones(3x3,3nz) */
  casadi_fill(w8, 3, 1.);
  /* #21: @13 = zeros(3x3,0nz) */
  /* #22: @14 = horzcat(@8, @13) */
  rr=w14;
  for (i=0, cs=w8; i<3; ++i) *rr++ = *cs++;
  /* #23: @8 = @14' */
  casadi_trans(w14,casadi_s1, w8, casadi_s0, iw);
  /* #24: @10 = mac(@12,@8,@10) */
  casadi_mtimes(w12, casadi_s3, w8, casadi_s0, w10, casadi_s2, w, 0);
  /* #25: @3 = mac(@10,@7,@3) */
  for (i=0, rr=w3; i<1; ++i) for (j=0; j<7; ++j, ++rr) for (k=0, ss=w10+j, tt=w7+i*3; k<3; ++k) *rr += ss[k*7]**tt++;
  /* #26: @3 = (@2+@3) */
  for (i=0, rr=w3, cr=w2, cs=w3; i<7; ++i) (*rr++)  = ((*cr++)+(*cs++));
  /* #27: @15 = input[1][4] */
  casadi_copy(arg[1] ? arg[1]+109 : 0, 7, w15);
  /* #28: @3 = (@3-@15) */
  for (i=0, rr=w3, cs=w15; i<7; ++i) (*rr++) -= (*cs++);
  /* #29: output[1][0] = @3 */
  casadi_copy(w3, 7, res[1]);
  /* #30: @3 = input[3][0] */
  casadi_copy(arg[3], 7, w3);
  /* #31: @1 = @1' */
  /* #32: @0 = input[2][0] */
  w0 = arg[2] ? arg[2][0] : 0;
  /* #33: @1 = (@1*@0) */
  for (i=0, rr=w1; i<7; ++i) (*rr++) *= w0;
  /* #34: @1 = (@3+@1) */
  for (i=0, rr=w1, cr=w3, cs=w1; i<7; ++i) (*rr++)  = ((*cr++)+(*cs++));
  /* #35: @15 = zeros(1x7) */
  casadi_clear(w15, 7);
  /* #36: @16 = @2' */
  casadi_copy(w2, 7, w16);
  /* #37: @16 = (@0*@16) */
  for (i=0, rr=w16, cs=w16; i<7; ++i) (*rr++)  = (w0*(*cs++));
  /* #38: @17 = @4' */
  for (i=0, rr=w17, cs=w4; i<7; ++i) for (j=0; j<7; ++j) rr[i+j*7] = *cs++;
  /* #39: @15 = mac(@16,@17,@15) */
  for (i=0, rr=w15; i<7; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w16+j, tt=w17+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #40: @15 = @15' */
  /* #41: @1 = (@1+@15) */
  for (i=0, rr=w1, cs=w15; i<7; ++i) (*rr++) += (*cs++);
  /* #42: output[2][0] = @1 */
  casadi_copy(w1, 7, res[2]);
  /* #43: @8 = zeros(3x1) */
  casadi_clear(w8, 3);
  /* #44: @18 = @10' */
  for (i=0, rr=w18, cs=w10; i<3; ++i) for (j=0; j<7; ++j) rr[i+j*3] = *cs++;
  /* #45: @8 = mac(@18,@3,@8) */
  for (i=0, rr=w8; i<1; ++i) for (j=0; j<3; ++j, ++rr) for (k=0, ss=w18+j, tt=w3+i*7; k<7; ++k) *rr += ss[k*3]**tt++;
  /* #46: @6 = @6' */
  /* #47: @6 = (@6*@0) */
  for (i=0, rr=w6; i<3; ++i) (*rr++) *= w0;
  /* #48: @8 = (@8+@6) */
  for (i=0, rr=w8, cs=w6; i<3; ++i) (*rr++) += (*cs++);
  /* #49: @6 = zeros(1x3) */
  casadi_clear(w6, 3);
  /* #50: @19 = @7' */
  casadi_copy(w7, 3, w19);
  /* #51: @19 = (@0*@19) */
  for (i=0, rr=w19, cs=w19; i<3; ++i) (*rr++)  = (w0*(*cs++));
  /* #52: @20 = @9' */
  for (i=0, rr=w20, cs=w9; i<3; ++i) for (j=0; j<3; ++j) rr[i+j*3] = *cs++;
  /* #53: @6 = mac(@19,@20,@6) */
  for (i=0, rr=w6; i<3; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w19+j, tt=w20+i*3; k<3; ++k) *rr += ss[k*1]**tt++;
  /* #54: @6 = @6' */
  /* #55: @8 = (@8+@6) */
  for (i=0, rr=w8, cs=w6; i<3; ++i) (*rr++) += (*cs++);
  /* #56: output[2][1] = @8 */
  if (res[2]) casadi_copy(w8, 3, res[2]+7);
  /* #57: @17 = zeros(7x7) */
  casadi_clear(w17, 49);
  /* #58: @1 = @2' */
  casadi_copy(w2, 7, w1);
  /* #59: @1 = (@0*@1) */
  for (i=0, rr=w1, cs=w1; i<7; ++i) (*rr++)  = (w0*(*cs++));
  /* #60: @17 = mac(@2,@1,@17) */
  for (i=0, rr=w17; i<7; ++i) for (j=0; j<7; ++j, ++rr) for (k=0, ss=w2+j, tt=w1+i*1; k<1; ++k) *rr += ss[k*7]**tt++;
  /* #61: @17 = vec(@17) */
  /* #62: @20 = zeros(3x3) */
  casadi_clear(w20, 9);
  /* #63: @8 = @7' */
  casadi_copy(w7, 3, w8);
  /* #64: @8 = (@0*@8) */
  for (i=0, rr=w8, cs=w8; i<3; ++i) (*rr++)  = (w0*(*cs++));
  /* #65: @20 = mac(@7,@8,@20) */
  for (i=0, rr=w20; i<3; ++i) for (j=0; j<3; ++j, ++rr) for (k=0, ss=w7+j, tt=w8+i*1; k<1; ++k) *rr += ss[k*3]**tt++;
  /* #66: @20 = vec(@20) */
  /* #67: @12 = zeros(7x6) */
  casadi_clear(w12, 42);
  /* #68: @18 = zeros(7x3) */
  casadi_clear(w18, 21);
  /* #69: @7 = @7' */
  /* #70: @18 = mac(@3,@7,@18) */
  for (i=0, rr=w18; i<3; ++i) for (j=0; j<7; ++j, ++rr) for (k=0, ss=w3+j, tt=w7+i*1; k<1; ++k) *rr += ss[k*7]**tt++;
  /* #71: @12 = mac(@18,@14,@12) */
  casadi_mtimes(w18, casadi_s2, w14, casadi_s1, w12, casadi_s3, w, 0);
  /* #72: @11 = @12' */
  for (i=0, rr=w11, cs=w12; i<6; ++i) for (j=0; j<7; ++j) rr[i+j*6] = *cs++;
  /* #73: @11 = vec(@11) */
  /* #74: @13 = zeros(9x1,0nz) */
  /* #75: @3 = (-@3) */
  for (i=0, rr=w3, cs=w3; i<7; ++i) *rr++ = (- *cs++ );
  /* #76: @21 = 00 */
  /* #77: @22 = 00 */
  /* #78: @23 = 00 */
  /* #79: @24 = vertcat(@17, @20, @11, @13, @3, @21, @22, @23) */
  rr=w24;
  for (i=0, cs=w17; i<49; ++i) *rr++ = *cs++;
  for (i=0, cs=w20; i<9; ++i) *rr++ = *cs++;
  for (i=0, cs=w11; i<42; ++i) *rr++ = *cs++;
  for (i=0, cs=w3; i<7; ++i) *rr++ = *cs++;
  /* #80: @25 = dense(@24) */
  casadi_densify(w24, casadi_s4, w25, 0);
  /* #81: output[3][0] = @25 */
  casadi_copy(w25, 119, res[3]);
  return 0;
}

/* nlp_f:(x[10],p[119])->(f) */
static int casadi_f3(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i, j, k;
  casadi_real *rr, *ss, *tt;
  casadi_real w0, *w1=w+2, *w2=w+9, *w3=w+16, *w4=w+23, w5, *w6=w+73, *w7=w+76, *w8=w+79, *w9=w+82;
  /* #0: @0 = 0 */
  w0 = 0.;
  /* #1: @1 = zeros(1x7) */
  casadi_clear(w1, 7);
  /* #2: @2 = input[0][0] */
  casadi_copy(arg[0], 7, w2);
  /* #3: @3 = @2' */
  casadi_copy(w2, 7, w3);
  /* #4: @4 = input[1][0] */
  casadi_copy(arg[1], 49, w4);
  /* #5: @1 = mac(@3,@4,@1) */
  for (i=0, rr=w1; i<7; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w3+j, tt=w4+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #6: @0 = mac(@1,@2,@0) */
  for (i=0, rr=(&w0); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w1+j, tt=w2+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #7: @5 = 0 */
  w5 = 0.;
  /* #8: @6 = zeros(1x3) */
  casadi_clear(w6, 3);
  /* #9: @7 = input[0][1] */
  casadi_copy(arg[0] ? arg[0]+7 : 0, 3, w7);
  /* #10: @8 = @7' */
  casadi_copy(w7, 3, w8);
  /* #11: @9 = input[1][1] */
  casadi_copy(arg[1] ? arg[1]+49 : 0, 9, w9);
  /* #12: @6 = mac(@8,@9,@6) */
  for (i=0, rr=w6; i<3; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w8+j, tt=w9+i*3; k<3; ++k) *rr += ss[k*1]**tt++;
  /* #13: @5 = mac(@6,@7,@5) */
  for (i=0, rr=(&w5); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w6+j, tt=w7+i*3; k<3; ++k) *rr += ss[k*1]**tt++;
  /* #14: @0 = (@0+@5) */
  w0 += w5;
  /* #15: output[0][0] = @0 */
  if (res[0]) res[0][0] = w0;
  return 0;
}

/* nlp_grad_f:(x[10],p[119])->(f,grad_f_x[10]) */
static int casadi_f4(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i, j, k;
  casadi_real *rr, *ss, *tt;
  const casadi_real *cs;
  casadi_real w0, *w1=w+2, *w2=w+9, *w3=w+16, *w4=w+23, w5, *w6=w+73, *w7=w+76, *w8=w+79, *w9=w+82, *w10=w+91, *w11=w+140;
  /* #0: @0 = 0 */
  w0 = 0.;
  /* #1: @1 = zeros(1x7) */
  casadi_clear(w1, 7);
  /* #2: @2 = input[0][0] */
  casadi_copy(arg[0], 7, w2);
  /* #3: @3 = @2' */
  casadi_copy(w2, 7, w3);
  /* #4: @4 = input[1][0] */
  casadi_copy(arg[1], 49, w4);
  /* #5: @1 = mac(@3,@4,@1) */
  for (i=0, rr=w1; i<7; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w3+j, tt=w4+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #6: @0 = mac(@1,@2,@0) */
  for (i=0, rr=(&w0); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w1+j, tt=w2+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #7: @5 = 0 */
  w5 = 0.;
  /* #8: @6 = zeros(1x3) */
  casadi_clear(w6, 3);
  /* #9: @7 = input[0][1] */
  casadi_copy(arg[0] ? arg[0]+7 : 0, 3, w7);
  /* #10: @8 = @7' */
  casadi_copy(w7, 3, w8);
  /* #11: @9 = input[1][1] */
  casadi_copy(arg[1] ? arg[1]+49 : 0, 9, w9);
  /* #12: @6 = mac(@8,@9,@6) */
  for (i=0, rr=w6; i<3; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w8+j, tt=w9+i*3; k<3; ++k) *rr += ss[k*1]**tt++;
  /* #13: @5 = mac(@6,@7,@5) */
  for (i=0, rr=(&w5); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w6+j, tt=w7+i*3; k<3; ++k) *rr += ss[k*1]**tt++;
  /* #14: @0 = (@0+@5) */
  w0 += w5;
  /* #15: output[0][0] = @0 */
  if (res[0]) res[0][0] = w0;
  /* #16: @1 = @1' */
  /* #17: @3 = zeros(1x7) */
  casadi_clear(w3, 7);
  /* #18: @2 = @2' */
  /* #19: @10 = @4' */
  for (i=0, rr=w10, cs=w4; i<7; ++i) for (j=0; j<7; ++j) rr[i+j*7] = *cs++;
  /* #20: @3 = mac(@2,@10,@3) */
  for (i=0, rr=w3; i<7; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w2+j, tt=w10+i*7; k<7; ++k) *rr += ss[k*1]**tt++;
  /* #21: @3 = @3' */
  /* #22: @1 = (@1+@3) */
  for (i=0, rr=w1, cs=w3; i<7; ++i) (*rr++) += (*cs++);
  /* #23: output[1][0] = @1 */
  casadi_copy(w1, 7, res[1]);
  /* #24: @6 = @6' */
  /* #25: @8 = zeros(1x3) */
  casadi_clear(w8, 3);
  /* #26: @7 = @7' */
  /* #27: @11 = @9' */
  for (i=0, rr=w11, cs=w9; i<3; ++i) for (j=0; j<3; ++j) rr[i+j*3] = *cs++;
  /* #28: @8 = mac(@7,@11,@8) */
  for (i=0, rr=w8; i<3; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w7+j, tt=w11+i*3; k<3; ++k) *rr += ss[k*1]**tt++;
  /* #29: @8 = @8' */
  /* #30: @6 = (@6+@8) */
  for (i=0, rr=w6, cs=w8; i<3; ++i) (*rr++) += (*cs++);
  /* #31: output[1][1] = @6 */
  if (res[1]) casadi_copy(w6, 3, res[1]+7);
  return 0;
}

/* nlp_g:(x[10],p[119])->(g[7]) */
static int casadi_f5(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i, j, k;
  casadi_real *rr, *ss, *tt;
  const casadi_real *cs;
  casadi_real *w0=w+7, *w1=w+14, *w2=w+21, *w3=w+42, *w4=w+84, *w5=w+126, *w7=w+129;
  /* #0: @0 = input[0][0] */
  casadi_copy(arg[0], 7, w0);
  /* #1: @1 = zeros(7x1) */
  casadi_clear(w1, 7);
  /* #2: @2 = zeros(7x3) */
  casadi_clear(w2, 21);
  /* #3: @3 = input[1][2] */
  casadi_copy(arg[1] ? arg[1]+58 : 0, 42, w3);
  /* #4: @4 = @3' */
  for (i=0, rr=w4, cs=w3; i<7; ++i) for (j=0; j<6; ++j) rr[i+j*7] = *cs++;
  /* #5: @5 = ones(3x3,3nz) */
  casadi_fill(w5, 3, 1.);
  /* #6: @6 = zeros(3x3,0nz) */
  /* #7: @7 = horzcat(@5, @6) */
  rr=w7;
  for (i=0, cs=w5; i<3; ++i) *rr++ = *cs++;
  /* #8: @5 = @7' */
  casadi_trans(w7,casadi_s1, w5, casadi_s0, iw);
  /* #9: @2 = mac(@4,@5,@2) */
  casadi_mtimes(w4, casadi_s3, w5, casadi_s0, w2, casadi_s2, w, 0);
  /* #10: @5 = input[0][1] */
  casadi_copy(arg[0] ? arg[0]+7 : 0, 3, w5);
  /* #11: @1 = mac(@2,@5,@1) */
  for (i=0, rr=w1; i<1; ++i) for (j=0; j<7; ++j, ++rr) for (k=0, ss=w2+j, tt=w5+i*3; k<3; ++k) *rr += ss[k*7]**tt++;
  /* #12: @0 = (@0+@1) */
  for (i=0, rr=w0, cs=w1; i<7; ++i) (*rr++) += (*cs++);
  /* #13: @1 = input[1][4] */
  casadi_copy(arg[1] ? arg[1]+109 : 0, 7, w1);
  /* #14: @0 = (@0-@1) */
  for (i=0, rr=w0, cs=w1; i<7; ++i) (*rr++) -= (*cs++);
  /* #15: output[0][0] = @0 */
  casadi_copy(w0, 7, res[0]);
  return 0;
}

/* nlp_jac_g:(x[10],p[119])->(g[7],jac_g_x[7x10,28nz]) */
static int casadi_f6(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i, j, k;
  casadi_real *rr, *ss, *tt;
  const casadi_real *cs;
  casadi_real *w0=w+7, *w1=w+14, *w2=w+21, *w3=w+42, *w4=w+84, *w5=w+126, *w7=w+129, *w8=w+132, w9, w10, *w11=w+162;
  /* #0: @0 = input[0][0] */
  casadi_copy(arg[0], 7, w0);
  /* #1: @1 = zeros(7x1) */
  casadi_clear(w1, 7);
  /* #2: @2 = zeros(7x3) */
  casadi_clear(w2, 21);
  /* #3: @3 = input[1][2] */
  casadi_copy(arg[1] ? arg[1]+58 : 0, 42, w3);
  /* #4: @4 = @3' */
  for (i=0, rr=w4, cs=w3; i<7; ++i) for (j=0; j<6; ++j) rr[i+j*7] = *cs++;
  /* #5: @5 = ones(3x3,3nz) */
  casadi_fill(w5, 3, 1.);
  /* #6: @6 = zeros(3x3,0nz) */
  /* #7: @7 = horzcat(@5, @6) */
  rr=w7;
  for (i=0, cs=w5; i<3; ++i) *rr++ = *cs++;
  /* #8: @5 = @7' */
  casadi_trans(w7,casadi_s1, w5, casadi_s0, iw);
  /* #9: @2 = mac(@4,@5,@2) */
  casadi_mtimes(w4, casadi_s3, w5, casadi_s0, w2, casadi_s2, w, 0);
  /* #10: @5 = input[0][1] */
  casadi_copy(arg[0] ? arg[0]+7 : 0, 3, w5);
  /* #11: @1 = mac(@2,@5,@1) */
  for (i=0, rr=w1; i<1; ++i) for (j=0; j<7; ++j, ++rr) for (k=0, ss=w2+j, tt=w5+i*3; k<3; ++k) *rr += ss[k*7]**tt++;
  /* #12: @0 = (@0+@1) */
  for (i=0, rr=w0, cs=w1; i<7; ++i) (*rr++) += (*cs++);
  /* #13: @1 = input[1][4] */
  casadi_copy(arg[1] ? arg[1]+109 : 0, 7, w1);
  /* #14: @0 = (@0-@1) */
  for (i=0, rr=w0, cs=w1; i<7; ++i) (*rr++) -= (*cs++);
  /* #15: output[0][0] = @0 */
  casadi_copy(w0, 7, res[0]);
  /* #16: @8 = zeros(10x7,28nz) */
  casadi_clear(w8, 28);
  /* #17: @0 = ones(10x1,7nz) */
  casadi_fill(w0, 7, 1.);
  /* #18: {@1, NULL} = vertsplit(@0) */
  casadi_copy(w0, 7, w1);
  /* #19: (@8[:28:4] = @1) */
  for (rr=w8+0, ss=w1; rr!=w8+28; rr+=4) *rr = *ss++;
  /* #20: @1 = zeros(7x1) */
  casadi_clear(w1, 7);
  /* #21: @9 = ones(10x1,1nz) */
  w9 = 1.;
  /* #22: {NULL, @10} = vertsplit(@9) */
  w10 = w9;
  /* #23: @1 = mac(@2,@10,@1) */
  casadi_mtimes(w2, casadi_s2, (&w10), casadi_s6, w1, casadi_s5, w, 0);
  /* #24: (@8[1:29:4] = @1) */
  for (rr=w8+1, ss=w1; rr!=w8+29; rr+=4) *rr = *ss++;
  /* #25: @1 = zeros(7x1) */
  casadi_clear(w1, 7);
  /* #26: @10 = ones(10x1,1nz) */
  w10 = 1.;
  /* #27: {NULL, @9} = vertsplit(@10) */
  w9 = w10;
  /* #28: @1 = mac(@2,@9,@1) */
  casadi_mtimes(w2, casadi_s2, (&w9), casadi_s7, w1, casadi_s5, w, 0);
  /* #29: (@8[2:30:4] = @1) */
  for (rr=w8+2, ss=w1; rr!=w8+30; rr+=4) *rr = *ss++;
  /* #30: @1 = zeros(7x1) */
  casadi_clear(w1, 7);
  /* #31: @9 = ones(10x1,1nz) */
  w9 = 1.;
  /* #32: {NULL, @10} = vertsplit(@9) */
  w10 = w9;
  /* #33: @1 = mac(@2,@10,@1) */
  casadi_mtimes(w2, casadi_s2, (&w10), casadi_s8, w1, casadi_s5, w, 0);
  /* #34: (@8[3:31:4] = @1) */
  for (rr=w8+3, ss=w1; rr!=w8+31; rr+=4) *rr = *ss++;
  /* #35: @11 = @8' */
  casadi_trans(w8,casadi_s10, w11, casadi_s9, iw);
  /* #36: output[1][0] = @11 */
  casadi_copy(w11, 28, res[1]);
  return 0;
}

/* nlp_hess_l:(x[10],p[119],lam_f,lam_g[7])->(triu_hess_gamma_x_x[10x10,34nz]) */
static int casadi_f7(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i, j;
  casadi_real *rr, *ss;
  const casadi_int *cii;
  const casadi_real *cs;
  casadi_real *w0=w+10, w1, *w2=w+69, *w3=w+76, w4, w5, w6, *w7=w+81, *w8=w+130, *w9=w+137, *w10=w+186, *w11=w+189, *w12=w+198, *w13=w+201, *w14=w+210, *w15=w+220, *w16=w+278;
  /* #0: @0 = zeros(10x10,58nz) */
  casadi_clear(w0, 58);
  /* #1: @1 = input[2][0] */
  w1 = arg[2] ? arg[2][0] : 0;
  /* #2: @2 = zeros(1x7) */
  casadi_clear(w2, 7);
  /* #3: @3 = ones(10x1,2nz) */
  casadi_fill(w3, 2, 1.);
  /* #4: {@4, @5} = vertsplit(@3) */
  w4 = w3[0];
  w5 = w3[1];
  /* #5: @6 = @4' */
  casadi_copy((&w4), 1, (&w6));
  /* #6: @7 = input[1][0] */
  casadi_copy(arg[1], 49, w7);
  /* #7: @2 = mac(@6,@7,@2) */
  casadi_mtimes((&w6), casadi_s13, w7, casadi_s12, w2, casadi_s11, w, 0);
  /* #8: @2 = @2' */
  /* #9: @2 = (@1*@2) */
  for (i=0, rr=w2, cs=w2; i<7; ++i) (*rr++)  = (w1*(*cs++));
  /* #10: @8 = zeros(1x7) */
  casadi_clear(w8, 7);
  /* #11: @4 = @4' */
  /* #12: @4 = (@1*@4) */
  w4  = (w1*w4);
  /* #13: @9 = @7' */
  for (i=0, rr=w9, cs=w7; i<7; ++i) for (j=0; j<7; ++j) rr[i+j*7] = *cs++;
  /* #14: @8 = mac(@4,@9,@8) */
  casadi_mtimes((&w4), casadi_s13, w9, casadi_s12, w8, casadi_s11, w, 0);
  /* #15: @8 = @8' */
  /* #16: @2 = (@2+@8) */
  for (i=0, rr=w2, cs=w8; i<7; ++i) (*rr++) += (*cs++);
  /* #17: @10 = zeros(1x3) */
  casadi_clear(w10, 3);
  /* #18: @4 = @5' */
  casadi_copy((&w5), 1, (&w4));
  /* #19: @11 = input[1][1] */
  casadi_copy(arg[1] ? arg[1]+49 : 0, 9, w11);
  /* #20: @10 = mac(@4,@11,@10) */
  casadi_mtimes((&w4), casadi_s16, w11, casadi_s15, w10, casadi_s14, w, 0);
  /* #21: @10 = @10' */
  /* #22: @10 = (@1*@10) */
  for (i=0, rr=w10, cs=w10; i<3; ++i) (*rr++)  = (w1*(*cs++));
  /* #23: @12 = zeros(1x3) */
  casadi_clear(w12, 3);
  /* #24: @5 = @5' */
  /* #25: @5 = (@1*@5) */
  w5  = (w1*w5);
  /* #26: @13 = @11' */
  for (i=0, rr=w13, cs=w11; i<3; ++i) for (j=0; j<3; ++j) rr[i+j*3] = *cs++;
  /* #27: @12 = mac(@5,@13,@12) */
  casadi_mtimes((&w5), casadi_s16, w13, casadi_s15, w12, casadi_s14, w, 0);
  /* #28: @12 = @12' */
  /* #29: @10 = (@10+@12) */
  for (i=0, rr=w10, cs=w12; i<3; ++i) (*rr++) += (*cs++);
  /* #30: @14 = vertcat(@2, @10) */
  rr=w14;
  for (i=0, cs=w2; i<7; ++i) *rr++ = *cs++;
  for (i=0, cs=w10; i<3; ++i) *rr++ = *cs++;
  /* #31: (@0[0, 1, 2, 3, 4, 5, 6, 49, 50, 51] = @14) */
  for (cii=casadi_s17, rr=w0, ss=w14; cii!=casadi_s17+10; ++cii, ++ss) rr[*cii] = *ss;
  /* #32: (@0[0, 7, 14, 21, 28, 35, 42, 49, 52, 55] = @14) */
  for (cii=casadi_s18, rr=w0, ss=w14; cii!=casadi_s18+10; ++cii, ++ss) rr[*cii] = *ss;
  /* #33: @2 = zeros(1x7) */
  casadi_clear(w2, 7);
  /* #34: @3 = ones(10x1,2nz) */
  casadi_fill(w3, 2, 1.);
  /* #35: {@5, @4} = vertsplit(@3) */
  w5 = w3[0];
  w4 = w3[1];
  /* #36: @6 = @5' */
  casadi_copy((&w5), 1, (&w6));
  /* #37: @2 = mac(@6,@7,@2) */
  casadi_mtimes((&w6), casadi_s19, w7, casadi_s12, w2, casadi_s11, w, 0);
  /* #38: @2 = @2' */
  /* #39: @2 = (@1*@2) */
  for (i=0, rr=w2, cs=w2; i<7; ++i) (*rr++)  = (w1*(*cs++));
  /* #40: @8 = zeros(1x7) */
  casadi_clear(w8, 7);
  /* #41: @5 = @5' */
  /* #42: @5 = (@1*@5) */
  w5  = (w1*w5);
  /* #43: @8 = mac(@5,@9,@8) */
  casadi_mtimes((&w5), casadi_s19, w9, casadi_s12, w8, casadi_s11, w, 0);
  /* #44: @8 = @8' */
  /* #45: @2 = (@2+@8) */
  for (i=0, rr=w2, cs=w8; i<7; ++i) (*rr++) += (*cs++);
  /* #46: @10 = zeros(1x3) */
  casadi_clear(w10, 3);
  /* #47: @5 = @4' */
  casadi_copy((&w4), 1, (&w5));
  /* #48: @10 = mac(@5,@11,@10) */
  casadi_mtimes((&w5), casadi_s20, w11, casadi_s15, w10, casadi_s14, w, 0);
  /* #49: @10 = @10' */
  /* #50: @10 = (@1*@10) */
  for (i=0, rr=w10, cs=w10; i<3; ++i) (*rr++)  = (w1*(*cs++));
  /* #51: @12 = zeros(1x3) */
  casadi_clear(w12, 3);
  /* #52: @4 = @4' */
  /* #53: @4 = (@1*@4) */
  w4  = (w1*w4);
  /* #54: @12 = mac(@4,@13,@12) */
  casadi_mtimes((&w4), casadi_s20, w13, casadi_s15, w12, casadi_s14, w, 0);
  /* #55: @12 = @12' */
  /* #56: @10 = (@10+@12) */
  for (i=0, rr=w10, cs=w12; i<3; ++i) (*rr++) += (*cs++);
  /* #57: @14 = vertcat(@2, @10) */
  rr=w14;
  for (i=0, cs=w2; i<7; ++i) *rr++ = *cs++;
  for (i=0, cs=w10; i<3; ++i) *rr++ = *cs++;
  /* #58: (@0[7, 8, 9, 10, 11, 12, 13, 52, 53, 54] = @14) */
  for (cii=casadi_s21, rr=w0, ss=w14; cii!=casadi_s21+10; ++cii, ++ss) rr[*cii] = *ss;
  /* #59: (@0[1, 8, 15, 22, 29, 36, 43, 50, 53, 56] = @14) */
  for (cii=casadi_s22, rr=w0, ss=w14; cii!=casadi_s22+10; ++cii, ++ss) rr[*cii] = *ss;
  /* #60: @2 = zeros(1x7) */
  casadi_clear(w2, 7);
  /* #61: @3 = ones(10x1,2nz) */
  casadi_fill(w3, 2, 1.);
  /* #62: {@4, @5} = vertsplit(@3) */
  w4 = w3[0];
  w5 = w3[1];
  /* #63: @6 = @4' */
  casadi_copy((&w4), 1, (&w6));
  /* #64: @2 = mac(@6,@7,@2) */
  casadi_mtimes((&w6), casadi_s23, w7, casadi_s12, w2, casadi_s11, w, 0);
  /* #65: @2 = @2' */
  /* #66: @2 = (@1*@2) */
  for (i=0, rr=w2, cs=w2; i<7; ++i) (*rr++)  = (w1*(*cs++));
  /* #67: @8 = zeros(1x7) */
  casadi_clear(w8, 7);
  /* #68: @4 = @4' */
  /* #69: @4 = (@1*@4) */
  w4  = (w1*w4);
  /* #70: @8 = mac(@4,@9,@8) */
  casadi_mtimes((&w4), casadi_s23, w9, casadi_s12, w8, casadi_s11, w, 0);
  /* #71: @8 = @8' */
  /* #72: @2 = (@2+@8) */
  for (i=0, rr=w2, cs=w8; i<7; ++i) (*rr++) += (*cs++);
  /* #73: @10 = zeros(1x3) */
  casadi_clear(w10, 3);
  /* #74: @4 = @5' */
  casadi_copy((&w5), 1, (&w4));
  /* #75: @10 = mac(@4,@11,@10) */
  casadi_mtimes((&w4), casadi_s24, w11, casadi_s15, w10, casadi_s14, w, 0);
  /* #76: @10 = @10' */
  /* #77: @10 = (@1*@10) */
  for (i=0, rr=w10, cs=w10; i<3; ++i) (*rr++)  = (w1*(*cs++));
  /* #78: @12 = zeros(1x3) */
  casadi_clear(w12, 3);
  /* #79: @5 = @5' */
  /* #80: @5 = (@1*@5) */
  w5  = (w1*w5);
  /* #81: @12 = mac(@5,@13,@12) */
  casadi_mtimes((&w5), casadi_s24, w13, casadi_s15, w12, casadi_s14, w, 0);
  /* #82: @12 = @12' */
  /* #83: @10 = (@10+@12) */
  for (i=0, rr=w10, cs=w12; i<3; ++i) (*rr++) += (*cs++);
  /* #84: @14 = vertcat(@2, @10) */
  rr=w14;
  for (i=0, cs=w2; i<7; ++i) *rr++ = *cs++;
  for (i=0, cs=w10; i<3; ++i) *rr++ = *cs++;
  /* #85: (@0[14, 15, 16, 17, 18, 19, 20, 55, 56, 57] = @14) */
  for (cii=casadi_s25, rr=w0, ss=w14; cii!=casadi_s25+10; ++cii, ++ss) rr[*cii] = *ss;
  /* #86: (@0[2, 9, 16, 23, 30, 37, 44, 51, 54, 57] = @14) */
  for (cii=casadi_s26, rr=w0, ss=w14; cii!=casadi_s26+10; ++cii, ++ss) rr[*cii] = *ss;
  /* #87: @2 = zeros(1x7) */
  casadi_clear(w2, 7);
  /* #88: @5 = ones(10x1,1nz) */
  w5 = 1.;
  /* #89: {@4, NULL} = vertsplit(@5) */
  w4 = w5;
  /* #90: @5 = @4' */
  casadi_copy((&w4), 1, (&w5));
  /* #91: @2 = mac(@5,@7,@2) */
  casadi_mtimes((&w5), casadi_s27, w7, casadi_s12, w2, casadi_s11, w, 0);
  /* #92: @2 = @2' */
  /* #93: @2 = (@1*@2) */
  for (i=0, rr=w2, cs=w2; i<7; ++i) (*rr++)  = (w1*(*cs++));
  /* #94: @8 = zeros(1x7) */
  casadi_clear(w8, 7);
  /* #95: @4 = @4' */
  /* #96: @4 = (@1*@4) */
  w4  = (w1*w4);
  /* #97: @8 = mac(@4,@9,@8) */
  casadi_mtimes((&w4), casadi_s27, w9, casadi_s12, w8, casadi_s11, w, 0);
  /* #98: @8 = @8' */
  /* #99: @2 = (@2+@8) */
  for (i=0, rr=w2, cs=w8; i<7; ++i) (*rr++) += (*cs++);
  /* #100: (@0[21:28] = @2) */
  for (rr=w0+21, ss=w2; rr!=w0+28; rr+=1) *rr = *ss++;
  /* #101: (@0[3:52:7] = @2) */
  for (rr=w0+3, ss=w2; rr!=w0+52; rr+=7) *rr = *ss++;
  /* #102: @2 = zeros(1x7) */
  casadi_clear(w2, 7);
  /* #103: @4 = ones(10x1,1nz) */
  w4 = 1.;
  /* #104: {@5, NULL} = vertsplit(@4) */
  w5 = w4;
  /* #105: @4 = @5' */
  casadi_copy((&w5), 1, (&w4));
  /* #106: @2 = mac(@4,@7,@2) */
  casadi_mtimes((&w4), casadi_s28, w7, casadi_s12, w2, casadi_s11, w, 0);
  /* #107: @2 = @2' */
  /* #108: @2 = (@1*@2) */
  for (i=0, rr=w2, cs=w2; i<7; ++i) (*rr++)  = (w1*(*cs++));
  /* #109: @8 = zeros(1x7) */
  casadi_clear(w8, 7);
  /* #110: @5 = @5' */
  /* #111: @5 = (@1*@5) */
  w5  = (w1*w5);
  /* #112: @8 = mac(@5,@9,@8) */
  casadi_mtimes((&w5), casadi_s28, w9, casadi_s12, w8, casadi_s11, w, 0);
  /* #113: @8 = @8' */
  /* #114: @2 = (@2+@8) */
  for (i=0, rr=w2, cs=w8; i<7; ++i) (*rr++) += (*cs++);
  /* #115: (@0[28:35] = @2) */
  for (rr=w0+28, ss=w2; rr!=w0+35; rr+=1) *rr = *ss++;
  /* #116: (@0[4:53:7] = @2) */
  for (rr=w0+4, ss=w2; rr!=w0+53; rr+=7) *rr = *ss++;
  /* #117: @2 = zeros(1x7) */
  casadi_clear(w2, 7);
  /* #118: @5 = ones(10x1,1nz) */
  w5 = 1.;
  /* #119: {@4, NULL} = vertsplit(@5) */
  w4 = w5;
  /* #120: @5 = @4' */
  casadi_copy((&w4), 1, (&w5));
  /* #121: @2 = mac(@5,@7,@2) */
  casadi_mtimes((&w5), casadi_s29, w7, casadi_s12, w2, casadi_s11, w, 0);
  /* #122: @2 = @2' */
  /* #123: @2 = (@1*@2) */
  for (i=0, rr=w2, cs=w2; i<7; ++i) (*rr++)  = (w1*(*cs++));
  /* #124: @8 = zeros(1x7) */
  casadi_clear(w8, 7);
  /* #125: @4 = @4' */
  /* #126: @4 = (@1*@4) */
  w4  = (w1*w4);
  /* #127: @8 = mac(@4,@9,@8) */
  casadi_mtimes((&w4), casadi_s29, w9, casadi_s12, w8, casadi_s11, w, 0);
  /* #128: @8 = @8' */
  /* #129: @2 = (@2+@8) */
  for (i=0, rr=w2, cs=w8; i<7; ++i) (*rr++) += (*cs++);
  /* #130: (@0[35:42] = @2) */
  for (rr=w0+35, ss=w2; rr!=w0+42; rr+=1) *rr = *ss++;
  /* #131: (@0[5:54:7] = @2) */
  for (rr=w0+5, ss=w2; rr!=w0+54; rr+=7) *rr = *ss++;
  /* #132: @2 = zeros(1x7) */
  casadi_clear(w2, 7);
  /* #133: @4 = ones(10x1,1nz) */
  w4 = 1.;
  /* #134: {@5, NULL} = vertsplit(@4) */
  w5 = w4;
  /* #135: @4 = @5' */
  casadi_copy((&w5), 1, (&w4));
  /* #136: @2 = mac(@4,@7,@2) */
  casadi_mtimes((&w4), casadi_s30, w7, casadi_s12, w2, casadi_s11, w, 0);
  /* #137: @2 = @2' */
  /* #138: @2 = (@1*@2) */
  for (i=0, rr=w2, cs=w2; i<7; ++i) (*rr++)  = (w1*(*cs++));
  /* #139: @8 = zeros(1x7) */
  casadi_clear(w8, 7);
  /* #140: @5 = @5' */
  /* #141: @1 = (@1*@5) */
  w1 *= w5;
  /* #142: @8 = mac(@1,@9,@8) */
  casadi_mtimes((&w1), casadi_s30, w9, casadi_s12, w8, casadi_s11, w, 0);
  /* #143: @8 = @8' */
  /* #144: @2 = (@2+@8) */
  for (i=0, rr=w2, cs=w8; i<7; ++i) (*rr++) += (*cs++);
  /* #145: (@0[42:49] = @2) */
  for (rr=w0+42, ss=w2; rr!=w0+49; rr+=1) *rr = *ss++;
  /* #146: (@0[6:55:7] = @2) */
  for (rr=w0+6, ss=w2; rr!=w0+55; rr+=7) *rr = *ss++;
  /* #147: @15 = @0' */
  casadi_trans(w0,casadi_s31, w15, casadi_s31, iw);
  /* #148: @16 = project(@15) */
  casadi_project(w15, casadi_s31, w16, casadi_s32, w);
  /* #149: output[0][0] = @16 */
  casadi_copy(w16, 34, res[0]);
  return 0;
}

bool casadi_nlp_f0(ipindex n, ipnumber *x, bool new_x, ipnumber *obj_value, UserDataPtr user_data) {
  struct casadi_ipopt_data* d = (struct casadi_ipopt_data*) user_data;
  d->arg[0] = x;
  d->arg[1] = d->nlp->p;
  d->res[0] = obj_value;
  if (casadi_f3(d->arg, d->res, d->iw, d->w, 0)) return false;
  return true;
}
bool casadi_nlp_g0(ipindex n, ipnumber *x, bool new_x, ipindex m, ipnumber *g, UserDataPtr user_data) {
  struct casadi_ipopt_data* d = (struct casadi_ipopt_data*) user_data;
  d->arg[0] = x;
  d->arg[1] = d->nlp->p;
  d->res[0] = g;
  if (casadi_f5(d->arg, d->res, d->iw, d->w, 0)) return false;
  return true;
}
bool casadi_nlp_grad_f0(ipindex n, ipnumber *x, bool new_x, ipnumber *grad_f, UserDataPtr user_data) {
  struct casadi_ipopt_data* d = (struct casadi_ipopt_data*) user_data;
  d->arg[0] = x;
  d->arg[1] = d->nlp->p;
  d->res[0] = 0;
  d->res[1] = grad_f;
  if (casadi_f4(d->arg, d->res, d->iw, d->w, 0)) return false;
  return true;
}
bool casadi_nlp_jac_g0(ipindex n, ipnumber *x, bool new_x, ipindex m, ipindex nele_jac, ipindex *iRow, ipindex *jCol, ipnumber *values, UserDataPtr user_data) {
  struct casadi_ipopt_data* d = (struct casadi_ipopt_data*) user_data;
  if (values) {
    d->arg[0] = x;
    d->arg[1] = d->nlp->p;
    d->res[0] = 0;
    d->res[1] = values;
    if (casadi_f6(d->arg, d->res, d->iw, d->w, 0)) return false;
  } else {
    casadi_ipopt_sparsity(d->prob->sp_a, iRow, jCol);
  }
  return true;
}
bool casadi_nlp_hess_l0(ipindex n, ipnumber *x, bool new_x, ipnumber obj_factor,ipindex m, ipnumber *lambda, bool new_lambda, ipindex nele_hess, ipindex *iRow, ipindex *jCol, ipnumber *values, UserDataPtr user_data) {
  struct casadi_ipopt_data* d = (struct casadi_ipopt_data*) user_data;
  if (values) {
    d->arg[0] = x;
    d->arg[1] = d->nlp->p;
    d->arg[2] = &obj_factor;
    d->arg[3] = lambda;
    d->res[0] = values;
    if (casadi_f7(d->arg, d->res, d->iw, d->w, 0)) return false;
    return true;
  } else {
    casadi_ipopt_sparsity(d->prob->sp_h, iRow, jCol);
  }
  return true;
}
/* solver:(x0[10],p[119],lbx[10],ubx[10],lbg[7],ubg[7],lam_x0[10],lam_g0[7])->(x[10],f,g[7],lam_x[10],lam_g[7],lam_p[119]) */
static int casadi_f1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  const casadi_real one=1;
  struct casadi_ipopt_data* d=&casadi_f1_mem[mem];
  struct casadi_ipopt_prob p;
  struct casadi_nlpsol_data d_nlp;
  struct casadi_nlpsol_prob p_nlp;
  d_nlp.p = arg[1];
  d_nlp.lbx = arg[2];
  d_nlp.ubx = arg[3];
  d_nlp.lbg = arg[4];
  d_nlp.ubg = arg[5];
  d_nlp.x0 = arg[0];
  d_nlp.lam_x0 = arg[6];
  d_nlp.lam_g0 = arg[7];
  d_nlp.x = res[0];
  d_nlp.f = res[1];
  d_nlp.g = res[2];
  d_nlp.lam_x = res[3];
  d_nlp.lam_g = res[4];
  d_nlp.lam_p = res[5];
  d_nlp.prob = &p_nlp;
  p_nlp.nx = 10;
  p_nlp.ng = 7;
  p_nlp.np = 119;
  p_nlp.detect_bounds.ng = 0;
  casadi_nlpsol_init(&d_nlp, &arg, &res, &iw, &w);
  if (d_nlp.x0) {
    casadi_copy(d_nlp.x0, 10, d_nlp.z);
  } else {
    casadi_clear(d_nlp.z, 10);
  }
  if (d_nlp.lbx) {
    casadi_copy(d_nlp.lbx, 10, d_nlp.lbz);
  } else {
    casadi_fill(d_nlp.lbz, 10, -casadi_inf);
  }
  if (d_nlp.ubx) {
    casadi_copy(d_nlp.ubx, 10, d_nlp.ubz);
  } else {
    casadi_fill(d_nlp.ubz, 10, casadi_inf);
  }
  if (d_nlp.lam_x0) {
    casadi_copy(d_nlp.lam_x0, 10, d_nlp.lam);
  } else {
    casadi_clear(d_nlp.lam, 10);
  }
  if (d_nlp.lbg) {
    casadi_copy(d_nlp.lbg, 7, d_nlp.lbz+10);
  } else {
    casadi_fill(d_nlp.lbz+10, 7, -casadi_inf);
  }
  if (d_nlp.ubg) {
    casadi_copy(d_nlp.ubg, 7, d_nlp.ubz+10);
  } else {
    casadi_fill(d_nlp.ubz+10, 7, casadi_inf);
  }
  if (d_nlp.lam_g0) {
    casadi_copy(d_nlp.lam_g0, 7, d_nlp.lam+10);
  } else {
    casadi_clear(d_nlp.lam+10, 7);
  }
  d->nlp = &d_nlp;
  d->prob = &p;
  p.nlp = &p_nlp;
  p.sp_a = casadi_s9;
  p.sp_h = casadi_s32;
  casadi_ipopt_setup(&p);
  p.eval_f = casadi_nlp_f0;
  p.eval_g = casadi_nlp_g0;
  p.eval_grad_f = casadi_nlp_grad_f0;
  p.eval_jac_g = casadi_nlp_jac_g0;
  p.eval_h = casadi_nlp_hess_l0;
  casadi_ipopt_init(d, &arg, &res, &iw, &w);
  casadi_ipopt_presolve(d);
  AddIpoptIntOption(d->ipopt, "print_level",0);
  AddIpoptStrOption(d->ipopt, "sb","yes");
  AddIpoptStrOption(d->ipopt, "linear_solver","mumps");
  casadi_ipopt_solve(d);
  d->arg[0] = d_nlp.z;
  d->arg[1] = d_nlp.p;
  d->arg[2] = &one;
  d->arg[3] = d_nlp.lam+10;
  d->res[0] = 0;
  d->res[1] = 0;
  d->res[2] = 0;
  d->res[3] = d_nlp.lam_p;
  if (casadi_f2(d->arg, d->res, d->iw, d->w, 0)) return 1;
  casadi_scal(119, -1.0, d_nlp.lam_p);
  casadi_copy(d_nlp.z, 10, d_nlp.x);
  casadi_copy(d_nlp.z + 10, 7, d_nlp.g);
  casadi_copy(d_nlp.lam, 10, d_nlp.lam_x);
  casadi_copy(d_nlp.lam + 10, 7, d_nlp.lam_g);
  if (d_nlp.f) casadi_copy(&d_nlp.objective, 1, d_nlp.f);
  if (d_nlp.lam_p) casadi_copy(d_nlp.lam_p, 119, d_nlp.lam_p);
  return 0;
  return 0;
}

int casadi_f1_alloc_mem(void) {
  return casadi_f1_mem_counter++;
}

int casadi_f1_init_mem(int mem) {
  ipopt_init_mem(&casadi_f1_mem[mem]);
  return 0;
}

void casadi_f1_free_mem(int mem) {
  ipopt_free_mem(&casadi_f1_mem[mem]);
}

int casadi_f1_checkout(void) {
  int mid;
  if (casadi_f1_unused_stack_counter>=0) {
    return casadi_f1_unused_stack[casadi_f1_unused_stack_counter--];
  } else {
    if (casadi_f1_mem_counter==CASADI_MAX_NUM_THREADS) return -1;
    mid = casadi_f1_alloc_mem();
    if (mid<0) return -1;
    if(casadi_f1_init_mem(mid)) return -1;
    return mid;
  }
}

void casadi_f1_release(int mem) {
  casadi_f1_unused_stack[++casadi_f1_unused_stack_counter] = mem;
}

/* GravOpt_Wrench:(J[6x7],Gvec[7],R_eef[3x3],W_tau[7x7],W_gamma[3x3],tau_lim,gamma_llim,gamma_ulim)->(tau_opt[7],gamma_space_opt[3]) */
static int casadi_f0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i, j, k;
  casadi_real **res1=res+2, *rr, *ss, *tt;
  const casadi_real **arg1=arg+8, *cs;
  int flag, mid;
  casadi_real *w0=w+674, *w1=w+684, *w2=w+733, *w3=w+742, *w4=w+784, *w5=w+793, *w6=w+802, w7, w8, w9, *w10=w+812, w11, *w12=w+932, *w13=w+942, *w14=w+952, *w15=w+962, *w16=w+965;
  /* #0: @0 = zeros(10x1) */
  casadi_clear(w0, 10);
  /* #1: @1 = input[3][0] */
  casadi_copy(arg[3], 49, w1);
  /* #2: @1 = vec(@1) */
  /* #3: @2 = input[4][0] */
  casadi_copy(arg[4], 9, w2);
  /* #4: @2 = vec(@2) */
  /* #5: @3 = input[0][0] */
  casadi_copy(arg[0], 42, w3);
  /* #6: @3 = vec(@3) */
  /* #7: @4 = input[2][0] */
  casadi_copy(arg[2], 9, w4);
  /* #8: @5 = vec(@4) */
  casadi_copy(w4, 9, w5);
  /* #9: @6 = input[1][0] */
  casadi_copy(arg[1], 7, w6);
  /* #10: @7 = input[5][0] */
  w7 = arg[5] ? arg[5][0] : 0;
  /* #11: @8 = input[6][0] */
  w8 = arg[6] ? arg[6][0] : 0;
  /* #12: @9 = input[7][0] */
  w9 = arg[7] ? arg[7][0] : 0;
  /* #13: @10 = vertcat(@1, @2, @3, @5, @6, @7, @8, @9) */
  rr=w10;
  for (i=0, cs=w1; i<49; ++i) *rr++ = *cs++;
  for (i=0, cs=w2; i<9; ++i) *rr++ = *cs++;
  for (i=0, cs=w3; i<42; ++i) *rr++ = *cs++;
  for (i=0, cs=w5; i<9; ++i) *rr++ = *cs++;
  for (i=0, cs=w6; i<7; ++i) *rr++ = *cs++;
  *rr++ = w7;
  *rr++ = w8;
  *rr++ = w9;
  /* #14: @11 = (-@7) */
  w11 = (- w7 );
  /* #15: @12 = vertcat(@11, @11, @11, @11, @11, @11, @11, @8, @8, @8) */
  rr=w12;
  *rr++ = w11;
  *rr++ = w11;
  *rr++ = w11;
  *rr++ = w11;
  *rr++ = w11;
  *rr++ = w11;
  *rr++ = w11;
  *rr++ = w8;
  *rr++ = w8;
  *rr++ = w8;
  /* #16: @13 = vertcat(@7, @7, @7, @7, @7, @7, @7, @9, @9, @9) */
  rr=w13;
  *rr++ = w7;
  *rr++ = w7;
  *rr++ = w7;
  *rr++ = w7;
  *rr++ = w7;
  *rr++ = w7;
  *rr++ = w7;
  *rr++ = w9;
  *rr++ = w9;
  *rr++ = w9;
  /* #17: @6 = zeros(7x1) */
  casadi_clear(w6, 7);
  /* #18: {@14, NULL, NULL, NULL, NULL, NULL} = solver(@0, @10, @12, @13, @6, @6, @0, @6) */
  arg1[0]=w0;
  arg1[1]=w10;
  arg1[2]=w12;
  arg1[3]=w13;
  arg1[4]=w6;
  arg1[5]=w6;
  arg1[6]=w0;
  arg1[7]=w6;
  res1[0]=w14;
  res1[1]=0;
  res1[2]=0;
  res1[3]=0;
  res1[4]=0;
  res1[5]=0;
  mid = casadi_f1_checkout();
  if (mid<0) return 1;
  flag = casadi_f1(arg1, res1, iw, w, mid);
  casadi_f1_release(mid);
  if (flag) return 1;
  /* #19: @6 = @14[:7] */
  for (rr=w6, ss=w14+0; ss!=w14+7; ss+=1) *rr++ = *ss;
  /* #20: output[0][0] = @6 */
  casadi_copy(w6, 7, res[0]);
  /* #21: @15 = zeros(3x1) */
  casadi_clear(w15, 3);
  /* #22: @16 = @14[7:10] */
  for (rr=w16, ss=w14+7; ss!=w14+10; ss+=1) *rr++ = *ss;
  /* #23: @15 = mac(@4,@16,@15) */
  for (i=0, rr=w15; i<1; ++i) for (j=0; j<3; ++j, ++rr) for (k=0, ss=w4+j, tt=w16+i*3; k<3; ++k) *rr += ss[k*3]**tt++;
  /* #24: output[1][0] = @15 */
  casadi_copy(w15, 3, res[1]);
  return 0;
}

CASADI_SYMBOL_EXPORT int GravOpt_Wrench(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
  return casadi_f0(arg, res, iw, w, mem);
}

CASADI_SYMBOL_EXPORT int GravOpt_Wrench_alloc_mem(void) {
  return 0;
}

CASADI_SYMBOL_EXPORT int GravOpt_Wrench_init_mem(int mem) {
  return 0;
}

CASADI_SYMBOL_EXPORT void GravOpt_Wrench_free_mem(int mem) {
}

CASADI_SYMBOL_EXPORT int GravOpt_Wrench_checkout(void) {
  return 0;
}

CASADI_SYMBOL_EXPORT void GravOpt_Wrench_release(int mem) {
}

CASADI_SYMBOL_EXPORT void GravOpt_Wrench_incref(void) {
}

CASADI_SYMBOL_EXPORT void GravOpt_Wrench_decref(void) {
}

CASADI_SYMBOL_EXPORT casadi_int GravOpt_Wrench_n_in(void) { return 8;}

CASADI_SYMBOL_EXPORT casadi_int GravOpt_Wrench_n_out(void) { return 2;}

CASADI_SYMBOL_EXPORT casadi_real GravOpt_Wrench_default_in(casadi_int i) {
  switch (i) {
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const char* GravOpt_Wrench_name_in(casadi_int i) {
  switch (i) {
    case 0: return "J";
    case 1: return "Gvec";
    case 2: return "R_eef";
    case 3: return "W_tau";
    case 4: return "W_gamma";
    case 5: return "tau_lim";
    case 6: return "gamma_llim";
    case 7: return "gamma_ulim";
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const char* GravOpt_Wrench_name_out(casadi_int i) {
  switch (i) {
    case 0: return "tau_opt";
    case 1: return "gamma_space_opt";
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const casadi_int* GravOpt_Wrench_sparsity_in(casadi_int i) {
  switch (i) {
    case 0: return casadi_s33;
    case 1: return casadi_s5;
    case 2: return casadi_s15;
    case 3: return casadi_s12;
    case 4: return casadi_s15;
    case 5: return casadi_s34;
    case 6: return casadi_s34;
    case 7: return casadi_s34;
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const casadi_int* GravOpt_Wrench_sparsity_out(casadi_int i) {
  switch (i) {
    case 0: return casadi_s5;
    case 1: return casadi_s35;
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT int GravOpt_Wrench_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
  if (sz_arg) *sz_arg = 28;
  if (sz_res) *sz_res = 13;
  if (sz_iw) *sz_iw = 11;
  if (sz_w) *sz_w = 968;
  return 0;
}

CASADI_SYMBOL_EXPORT int GravOpt_Wrench_work_bytes(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
  if (sz_arg) *sz_arg = 28*sizeof(const casadi_real*);
  if (sz_res) *sz_res = 13*sizeof(casadi_real*);
  if (sz_iw) *sz_iw = 11*sizeof(casadi_int);
  if (sz_w) *sz_w = 968*sizeof(casadi_real);
  return 0;
}


#ifdef __cplusplus
} /* extern "C" */
#endif
